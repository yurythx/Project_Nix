from django.contrib.auth.mixins import LoginRequiredMixin, UserPassesTestMixin
from django.contrib import messages
from django.shortcuts import redirect
from django.urls import reverse
from django.core.exceptions import PermissionDenied
from django.http import Http404
from django.core.cache import cache
from django.db.models import Q
from typing import Optional, Any, List
from apps.config.services.module_service import ModuleService


class SuccessMessageMixin:
    """Adiciona mensagem de sucesso ao contexto da view"""
    success_message = None
    def form_valid(self, form):
        response = super().form_valid(form)
        if self.success_message:
            from django.contrib import messages
            messages.success(self.request, self.success_message)
        return response 

class ModuleEnabledRequiredMixin:
    module_name = None  # Ex: 'apps.articles'

    def dispatch(self, request, *args, **kwargs):
        service = ModuleService()
        if not self.module_name:
            raise ValueError('Defina module_name no Mixin')
        if not service.is_module_enabled(self.module_name):
            raise Http404('M√≥dulo inativo')
        return super().dispatch(request, *args, **kwargs) 


# ============================================================================
# NOVA ARQUITETURA DE PERMISS√ïES REUTILIZ√ÅVEL
# ============================================================================

class BasePermissionMixin(UserPassesTestMixin):
    """
    Mixin base para controle de permiss√µes com cache inteligente.
    
    Esta classe serve como base para todos os mixins de permiss√£o,
    fornecendo funcionalidades comuns como cache, logging e tratamento de erros.
    """
    
    # Configura√ß√µes padr√£o
    permission_denied_message = "üö´ Acesso negado! Voc√™ n√£o tem permiss√£o para realizar esta a√ß√£o."
    redirect_url = 'pages:home'
    cache_timeout = 300  # 5 minutos
    
    # Grupos permitidos por padr√£o
    allowed_groups = ['administrador', 'admin', 'editor']
    
    def test_func(self):
        """Verifica se o usu√°rio tem permiss√µes adequadas."""
        user = self.request.user
        
        if not user.is_authenticated:
            return False
        
        # Superuser sempre tem acesso
        if user.is_superuser:
            return True
        
        # Verifica permiss√µes espec√≠ficas
        return self._check_permissions(user)
    
    def _check_permissions(self, user) -> bool:
        """Verifica permiss√µes espec√≠ficas. Deve ser sobrescrito pelas subclasses."""
        # Por padr√£o, verifica grupos permitidos
        return self._has_allowed_group(user)
    
    def _has_allowed_group(self, user) -> bool:
        """Verifica se o usu√°rio pertence a grupos permitidos com cache distribu√≠do."""
        from core.cache_service import cache_service
        
        # Tenta obter do cache distribu√≠do
        has_group = cache_service.get_user_groups(user.id, self.allowed_groups)
        
        if has_group is None:
            # Consulta ao banco se n√£o estiver no cache
            query = Q()
            for group in self.allowed_groups:
                query |= Q(name__iexact=group)
            has_group = user.groups.filter(query).exists()
            
            # Armazena no cache distribu√≠do
            cache_service.set_user_groups(user.id, self.allowed_groups, has_group, self.cache_timeout)
        
        return has_group
    
    def handle_no_permission(self):
        """Trata quando o usu√°rio n√£o tem permiss√£o."""
        if not self.request.user.is_authenticated:
            messages.warning(
                self.request,
                'üîê Para acessar esta funcionalidade, voc√™ precisa fazer login primeiro.'
            )
            return redirect('accounts:login')
        
        messages.error(self.request, self.permission_denied_message)
        return redirect(self.redirect_url)
    
    def log_access_attempt(self, user, success: bool, details: str = ""):
        """Log de tentativa de acesso para auditoria."""
        try:
            import logging
            logger = logging.getLogger(__name__)
            status = "SUCCESS" if success else "DENIED"
            logger.info(
                f"Permission check: User {user.username} - {status} - "
                f"Path: {self.request.path} - {details}"
            )
        except Exception:
            pass  # N√£o falha se o logging n√£o funcionar


class StaffOrSuperuserRequiredMixin(BasePermissionMixin):
    """
    Mixin que verifica se o usu√°rio √© membro da equipe (staff) ou superusu√°rio.
    
    Permite acesso para:
    - Superusu√°rios
    - Usu√°rios staff
    - Usu√°rios dos grupos configurados
    """
    
    def _check_permissions(self, user) -> bool:
        """Verifica se o usu√°rio √© staff ou pertence aos grupos permitidos."""
        if user.is_staff:
            return True
        return self._has_allowed_group(user)


class BaseOwnerOrStaffMixin(StaffOrSuperuserRequiredMixin):
    """
    Mixin base para verifica√ß√£o de propriedade de objetos.
    
    Esta classe fornece a estrutura base para mixins que verificam
    se o usu√°rio √© o propriet√°rio de um objeto espec√≠fico.
    """
    
    def _get_owner(self, obj: Any) -> Optional[Any]:
        """
        Obt√©m o propriet√°rio do objeto. Deve ser sobrescrito pelas classes filhas.
        
        Args:
            obj: O objeto para verificar a propriedade
            
        Returns:
            O usu√°rio propriet√°rio ou None se n√£o encontrado
        """
        raise NotImplementedError("Subclasses devem implementar _get_owner")
    
    def _check_permissions(self, user) -> bool:
        """Verifica se o usu√°rio √© o propriet√°rio do objeto ou tem permiss√£o de staff."""
        # Se for staff ou superusu√°rio, permite o acesso
        if super()._check_permissions(user):
            return True
        
        # Para outros usu√°rios, verifica se √© o propriet√°rio
        try:
            obj = self.get_object()
            owner = self._get_owner(obj)
            has_access = owner == user if owner else False
            
            # Log da tentativa
            self.log_access_attempt(
                user, 
                has_access, 
                f"Object owner: {owner.username if owner else 'None'}"
            )
            
            return has_access
            
        except Exception as e:
            # Log do erro para debug
            import logging
            logger = logging.getLogger(__name__)
            logger.warning(f"Erro ao verificar propriedade do objeto: {str(e)}")
            
            # Log da tentativa falhada
            self.log_access_attempt(user, False, f"Error: {str(e)}")
            return False


class ReadOnlyMixin(BasePermissionMixin):
    """
    Mixin para views somente leitura - n√£o requer permiss√µes especiais.
    
    Permite acesso para qualquer usu√°rio (autenticado ou n√£o).
    """
    
    def test_func(self):
        """Sempre retorna True para permitir acesso p√∫blico."""
        return True
    
    def handle_no_permission(self):
        """Nunca √© chamado, mas implementado por seguran√ßa."""
        return redirect(self.redirect_url)


class CreatorRequiredMixin(StaffOrSuperuserRequiredMixin):
    """
    Mixin que requer que o usu√°rio seja o criador do conte√∫do.
    
    Mais restritivo que OwnerOrStaffMixin - nem mesmo staff pode acessar
    conte√∫do de outros usu√°rios (exceto superusu√°rios).
    """
    
    permission_denied_message = "üö´ Acesso negado! Apenas o criador pode realizar esta a√ß√£o."
    
    def _check_permissions(self, user) -> bool:
        """Verifica se o usu√°rio √© o criador do objeto."""
        # Superusu√°rios sempre t√™m acesso
        if user.is_superuser:
            return True
        
        # Para outros usu√°rios, verifica se √© o criador
        try:
            obj = self.get_object()
            creator = getattr(obj, 'criado_por', None)
            has_access = creator == user if creator else False
            
            # Log da tentativa
            self.log_access_attempt(
                user, 
                has_access, 
                f"Object creator: {creator.username if creator else 'None'}"
            )
            
            return has_access
            
        except Exception as e:
            self.log_access_attempt(user, False, f"Error: {str(e)}")
            return False


# ============================================================================
# MIXINS ESPEC√çFICOS POR M√ìDULO
# ============================================================================

class ContentOwnerOrStaffMixin(BaseOwnerOrStaffMixin):
    """
    Mixin gen√©rico para conte√∫do que tem campo 'criado_por'.
    
    Pode ser usado em qualquer modelo que tenha um campo 'criado_por'
    apontando para o modelo User.
    """
    
    def _get_owner(self, obj):
        """Obt√©m o criador do conte√∫do."""
        return getattr(obj, 'criado_por', None)


class AuthorOrStaffMixin(BaseOwnerOrStaffMixin):
    """
    Mixin para conte√∫do que tem campo 'author'.
    
    Pode ser usado em modelos como Article que t√™m campo 'author'.
    """
    
    def _get_owner(self, obj):
        """Obt√©m o autor do conte√∫do."""
        return getattr(obj, 'author', None)


# ============================================================================
# MIXINS DE CONVENI√äNCIA
# ============================================================================

class AdminRequiredMixin(StaffOrSuperuserRequiredMixin):
    """
    Mixin que verifica se o usu√°rio tem permiss√µes de administrador.
    
    Permite acesso para:
    - Superusu√°rios
    - Usu√°rios staff
    - Usu√°rios do grupo 'administrador'
    - Usu√°rios do grupo 'admin'
    """
    
    allowed_groups = ['administrador', 'admin']


class EditorOrAdminRequiredMixin(StaffOrSuperuserRequiredMixin):
    """
    Mixin para controle de acesso de editores e administradores.
    
    Permite acesso para:
    - Superusu√°rios
    - Usu√°rios staff
    - Usu√°rios do grupo 'administrador'
    - Usu√°rios do grupo 'admin'
    - Usu√°rios do grupo 'editor'
    """
    
    allowed_groups = ['administrador', 'admin', 'editor']


class SuperuserRequiredMixin(BasePermissionMixin):
    """
    Mixin que verifica se o usu√°rio √© superusu√°rio.
    
    Permite acesso apenas para superusu√°rios.
    """
    
    permission_denied_message = "üö´ Acesso restrito! Apenas superusu√°rios podem acessar esta funcionalidade."
    
    def _check_permissions(self, user) -> bool:
        """Testa se o usu√°rio √© superusu√°rio."""
        return user.is_superuser


# ============================================================================
# DECORATORS PARA VIEWS BASEADAS EM FUN√á√ÉO
# ============================================================================

def admin_required(view_func):
    """
    Decorator para views baseadas em fun√ß√£o que requer permiss√µes de administrador.
    
    Usage:
        @admin_required
        def my_view(request):
            # view code here
    """
    def wrapper(request, *args, **kwargs):
        if not request.user.is_authenticated:
            messages.error(request, 'üîê Voc√™ precisa estar logado para acessar esta √°rea.')
            return redirect('pages:home')
        
        # Verificar permiss√µes
        user = request.user
        has_permission = (
            user.is_superuser or 
            user.is_staff or 
            user.groups.filter(name__iexact='administrador').exists() or
            user.groups.filter(name__iexact='admin').exists()
        )
        
        if not has_permission:
            messages.error(
                request, 
                'üö´ Acesso negado! Voc√™ precisa ser administrador para acessar esta √°rea.'
            )
            return redirect('accounts:profile')
        
        return view_func(request, *args, **kwargs)
    
    return wrapper


def superuser_required(view_func):
    """
    Decorator para views baseadas em fun√ß√£o que requer superusu√°rio.
    
    Usage:
        @superuser_required
        def my_view(request):
            # view code here
    """
    def wrapper(request, *args, **kwargs):
        if not request.user.is_authenticated:
            messages.error(request, 'üîê Voc√™ precisa estar logado para acessar esta √°rea.')
            return redirect('pages:home')
        
        if not request.user.is_superuser:
            messages.error(
                request, 
                'üö´ Acesso restrito! Apenas superusu√°rios podem acessar esta funcionalidade.'
            )
            return redirect('accounts:profile')
        
        return view_func(request, *args, **kwargs)
    
    return wrapper


def content_owner_required(view_func):
    """
    Decorator para views que requerem que o usu√°rio seja o propriet√°rio do conte√∫do.
    
    Usage:
        @content_owner_required
        def my_view(request, content_id):
            # view code here
    """
    def wrapper(request, *args, **kwargs):
        if not request.user.is_authenticated:
            messages.error(request, 'üîê Voc√™ precisa estar logado para acessar esta √°rea.')
            return redirect('pages:home')
        
        # Verificar se √© superusu√°rio ou staff
        if request.user.is_superuser or request.user.is_staff:
            return view_func(request, *args, **kwargs)
        
        # Para outros usu√°rios, verificar propriedade
        # Esta implementa√ß√£o √© gen√©rica - pode ser customizada por m√≥dulo
        messages.error(
            request, 
            'üö´ Acesso negado! Voc√™ s√≥ pode editar conte√∫do que voc√™ criou.'
        )
        return redirect('accounts:profile')
    
    return wrapper


# ============================================================================
# HELPER MIXINS
# ============================================================================

class PermissionHelperMixin:
    """
    Mixin helper para verifica√ß√µes de permiss√£o em templates.
    
    Adiciona informa√ß√µes de permiss√£o ao contexto das views.
    """
    
    def get_context_data(self, **kwargs):
        """Adiciona informa√ß√µes de permiss√£o ao contexto."""
        context = super().get_context_data(**kwargs)
        
        user = self.request.user
        context.update({
            'user_is_admin': self.user_is_admin(user),
            'user_is_superuser': user.is_superuser,
            'user_is_staff': user.is_staff,
            'user_groups': list(user.groups.values_list('name', flat=True)) if user.is_authenticated else [],
            'user_permissions': self.get_user_permissions(user),
        })
        
        return context
    
    def user_is_admin(self, user):
        """Verifica se o usu√°rio √© administrador."""
        if not user.is_authenticated:
            return False
        
        return (
            user.is_superuser or 
            user.is_staff or 
            user.groups.filter(name__iexact='administrador').exists() or
            user.groups.filter(name__iexact='admin').exists()
        )
    
    def get_user_permissions(self, user):
        """Retorna as permiss√µes do usu√°rio em formato de dicion√°rio."""
        if not user.is_authenticated:
            return {}
        
        return {
            'is_superuser': user.is_superuser,
            'is_staff': user.is_staff,
            'is_admin': self.user_is_admin(user),
            'groups': list(user.groups.values_list('name', flat=True)),
            'permissions': list(user.get_all_permissions()),
        }


class ConfigPermissionMixin(AdminRequiredMixin):
    """
    Mixin espec√≠fico para o m√≥dulo de configura√ß√µes.
    
    Herda de AdminRequiredMixin e adiciona valida√ß√µes espec√≠ficas.
    """
    
    def dispatch(self, request, *args, **kwargs):
        """Override do dispatch para adicionar logs de acesso."""
        # Verificar permiss√µes primeiro
        if not self.test_func():
            return self.handle_no_permission()
        
        # Log de acesso (opcional)
        self.log_access_attempt(request.user, True, f"Config access: {request.path}")
        
        return super().dispatch(request, *args, **kwargs)
    
    def get_client_ip(self, request):
        """Obt√©m o IP do cliente."""
        x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
        if x_forwarded_for:
            ip = x_forwarded_for.split(',')[0]
        else:
            ip = request.META.get('REMOTE_ADDR')
        return ip 